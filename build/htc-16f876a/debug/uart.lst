     1: #include "delay.h"
     2: #include "uart.h"
     3: #include "softser.h"
     4: #include "types.h"
     5: 
     6: 
     7: #ifdef USE_UART
     8: 
     9: #ifndef UART_BRG
    10: # if HIGH_SPEED == 1
    11: #  define UART_BRG ((uint16)((double)(_XTAL_FREQ) / (16 * (double)(UART_BAUD))) - 1)
    12: # else
    13: #  define UART_BRG ((uint16)((double)(_XTAL_FREQ) / (64 * (double)(UART_BAUD))) - 1)
    14: # endif
    15: #endif
    16: #define UART_TIMEOUT UART_BAUD
    17: 
    18: const uint8 uart_brg = UART_BRG;
    19: 
    20: /**
    21:  * Re-target POSIX function uart_putch
    22:  */
    23: void
    24: uart_putch(unsigned char byte) {
    25:   /* output one byte */
    26:   while(!TXIF) {
    27:     /* set when register is empty */
    28:     continue;
    29:   }
    30:   TXREG = (unsigned char)byte;
    31: }
    32: 
    33: int
    34: uart_getch(void) {
    35: 
    36:         if(uart_poll(UART_TIMEOUT)) {
    37:       uint8 ch;
    38:           ch = RCREG;
    39:           RCIF = 0;
    40:           return (int)ch;
    41:   }
    42:  return -1;
    43: }
    44: 
    45: 
    46: // returns 1 when start bit received or 0 when timeout
    47: //---------------------------------------------------------
    48: bit
    49: uart_poll(unsigned char bauds) {
    50: 
    51:     // TMR0 -= SOFTSER_BRG;            // load corrected baud value
    52: 
    53: 
    54:     TMR0 = (256 - SOFTSER_BRG_FN(bauds));
    55:     while( TMR0&(1<<7) ) {
    56:       if(RCIF)
    57:         return 1;
    58:     }
    59: 
    60:   return 0;
    61: }
    62: 
    63: /**
    64:  * ISR for UART receive
    65:  *
    66:  * @return received character or 0 if it's not UART interrupt
    67:  */
    68: unsigned char
    69: uart_isr(void) {
    70:   if(RCIF) {
    71:     RCIF = 0;
    72:     return RCREG;
    73:   }
    74:   return 0;
    75: }
    76: 
    77: void
    78: uart_enable(void) {
    79:   TXEN = 1;
    80:   SPEN = 1;
    81:   RCIE = 0;
    82:   RX_TRIS = 1;
    83:   TX_TRIS = 1;
    84: }
    85: 
    86: void
    87: uart_disable(void) {
    88:   TXEN = 0;
    89:   SPEN = 0;
    90:   RCIE = 0;
    91:   RX_TRIS = 0;
    92:   TX_TRIS = 0;
    93:   TX_PIN = 0;
    94:   RX_PIN = 0;
    95: }
    96: 
    97: void
    98: uart_init(void) {
    99:   /* Initilize baudrate generator and pins */
   100: 
   101:   RX_TRIS = 1;
   102:   TX_TRIS = 1;
   103:   SPBRG = UART_BRG; //UART_BRG;
   104: 
   105:   CREN = 1;
   106:   RX9D = (NINE == 1);
   107: 
   108:   BRGH = (HIGH_SPEED == 1);
   109:   TX9 = (NINE == 1);
   110: 
   111:   uart_enable();
   112: }
   113: 
   114: void uart_puts(const char * s) {
   115:   while(*s)
   116:     uart_putch(*s++);
   117: }
   118: 
   119: void uart_puts2(unsigned char * s) {
   120:   while(*s)
   121:     uart_putch(*s++);
   122: }
   123: #endif // USE_UART
